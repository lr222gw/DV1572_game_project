Tessellation 
We use both a Evaluation shader and a Controll shader to handle tessellation,
our controll shader takes patches with 3 vertices and only passes the input patch to the evaluation shader adding no extra control points.
It is also being used to set the tessellation levels based on the distance from camera to a point between each side of our patch.
A function is used to set the tessellation level, when the distance is far enough the level will decrease with quadratic falloff in 
order to get a smooth transistion between displaced areas and non displaced areas.
A uniform called tess_percent is used to let us change the overall tessellation level in our application, it takes a value from -1 to 1 (floats),
if we set this value to -1 it will remove all tessellation and setting it to 1 will tessellate everything within a fixed range.
Displacement mapping is done with the evaluation shader, simply by sampling a tessellation map using our interpolated uv-coordinate.
We can change the amount of displacement using a uniform, in the future we will also include a specified factor to each modelinstance, 
we need to do this since tessellating models with a different amount of vertices will result in how much impact the factor has, currently all 
tessellated models have the same factor.

Since we most likely not want to tessellate all models, a boolin our modelInstance class is used that specifies if the 
normal Geometry shader program should be used or our tessellation shader program. 
Since all tessellation shaderprograms need patches as input, we also use the bool to decide if we draw patches or vertices with the glDraw functions.

Shadowmapping
we create a shadowmap using a custom shaderprogram that only handles a depthbuffer, this is done before we preform our deffered renderings geometrypass.
Instead of implementing PCF we've decided to use a slightly higher resulotion of 2048x2048 for our depthmap texture, as magnifying filter linear interpolation is used to get 
a smoother shape. 
For our demo we've also decided that we don't want to light the areas around what's being affected by the light in order to get a more accurate picture of what is being 
lit and what part is going to cast shadows, in a game scenario it is most likely not going to act like this for most cases but could still occour and thus we wanted 
this to be a setting per shadowcaster (Not implemented yet (remmove?)). 
Our solution is so far only possible with directional lights, but we have designed it with support for other lighttypes in mind.
To create a light that cast a shadow we first create a instance of our Light Class, then we create a instance of our class ShadowCaster which takes a 
Shared pointer to a Light, based on that light we create a light matrix that we use to create our shadowmap.
In order to use this shadowmap we have to register it to our scenemanager using a function called set_shdowcasting, we do this since it is the scenemanager 
that will hold all models that eventually might have it's shadow casted. 
The scenemanager controll how the shadowmap is created under what condition it is set to be updated and  also holds the shaderprogram for the shadowmapping mentioned before.
The shadowmap is updated each frame it's needed to based on two conditions; 
We update the shadowmap if a model within the area of our shadowmap has transformed, 
we update the shadowmap if the lightsource position or the target position for our light has changed.
In order to not update the shadowmap for every change we do we instead to it at a maximum one time per frame, 
this is done by letting our scenemanager know that a model or lightposition/lighttarget has changed using a callback function on our modelinstance and light; 
this trigger will then change a bool which will be checked every rendered frame, if it has changed we will update the shadowmap and then flip the bool again so we dont 
have to update it until next time something related to the shadowcasting changes.
In order to more effectivly see how the light changes a shadowcasterdbg class was introduced, it simply marks the area our shadowcaster has effect within by placing 
different color monkeys at the end of the area in effect.